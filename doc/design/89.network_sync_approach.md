# Technical Design Specification: Optimistic Concurrency Control (OCC)

## 1. Executive Summary

This document outlines the architectural design for synchronizing the game state in a multiplayer crossword application. The chosen strategy is Optimistic Concurrency Control (OCC).

Core Principle: The system assumes collisions (simultaneous solves) are rare. Instead of locking the server (which hurts performance), clients send a "Base Version" with their updates. The server rejects any update that is not based on the latest version of the state.

Goal: Guarantee data consistency and prevent "Lost Updates" (where one player's move overwrites another's) without moving game logic to the server.

-----

## 2. Data Model Changes

To support OCC, the game state structure must be modified to track mutations over time.

### 2.1 Server State

The server must treat the game state as a versioned container. It currently holds a Matrix. It must now hold a State Container:

  - Grid: The actual game data (the 2D array/matrix).
  - Version: An integer (monotonically increasing) or a high-precision timestamp. This acts as the "Truth Token."

### 2.2 Client State

The client must track not only the visible grid but also the provenance of that grid.

  - Local Grid: The grid the player sees.
  - Confirmed Version: The version number of the last valid snapshot received from the server.

-----

## 3. Communication Protocol

The WebSocket protocol must be updated to include versioning metadata in both directions.

### 3.1 Server-to-Client (Broadcast)

When the server sends the matrix to clients, it must attach the current version number.

  - Payload: { "grid": [...], "version": 42 }

### 3.2 Client-to-Server (Update Request)

When a client sends a solution, it must strictly include the version number of the state it started from.

  - Payload: { "grid": [...], "base_version": 42 }

Note: The client does NOT send version: 43. The client sends base_version: 42, telling the server "I modified version 42".

-----

## 4. Server-Side Logic

The server acts as a "Gatekeeper of Consistency." It requires NO game logic, only version logic.

### 4.1 The "Check-and-Set" Operation

This operation must be atomic. In Python asyncio, this is achieved using a Lock around the handler for a specific game room.

Algorithm:

1.  Acquire Lock (Wait if another player is currently updating).
2.  Read the incoming message's base_version.
3.  Compare incoming base_version with the Server's current_version.

  - IF MATCH (base_version == current_version):

1.  Accept Update: Overwrite Server Grid with Client Grid.
2.  Increment: current_version = current_version + 1.
3.  Broadcast: Send new Grid + new Version to ALL players.
4.  Success: (Implicitly managed via broadcast).

  - IF MISMATCH (base_version < current_version):

1.  Reject Update: Do NOT update the grid.
2.  Notify Sender: Send a specialized CONFLICT error message to the specific client who failed. This message must contain the Server's current_grid and current_version.

-----

## 5. Client-Side Logic

This is where the complexity resides. The client must handle the rejection gracefully so the user does not feel a "bug."

### 5.1 The "Happy Path"

1.  User enters a word.
2.  Client sends base_version: 42.
3.  Server accepts, increments to 43, and broadcasts.
4.  Client receives version: 43.
5.  Client updates Confirmed Version to 43.

### 5.2 The "Conflict Path" (Rebase Strategy)

If the Client receives a CONFLICT message (meaning another player solved a word while this user was typing):

1.  Pause UI: Briefly block input to prevent cascading conflicts.
2.  Diff/Analyze:

  - The client has its pending local change (the word the user just tried to solve).
  - The client has the new server state (passed in the CONFLICT message).

1.  Re-Apply Logic (The Rebase):

  - Check the new server state at the coordinates of the user's pending word.
  - Case A: The word is already solved in the new state.

  - Action: Discard the local change.
  - UX: Show a visual cue (e.g., "Already solved by Player X!").
  - Result: No new network request is needed. Update local view to match server.

  - Case B: The word is NOT solved in the new state.

  - Action: Apply the user's word on top of the new server matrix.
  - Retry: Send a new request with the new base_version (e.g., send base_version: 43).

-----

## 6. Edge Case: Simultaneous Solves (Scoring)

Since the game counts "who solved what," we must ensure a point is only awarded once.

  - Problem: Player A and Player B send the solution for "WORD" at the exact same millisecond.
  - Resolution via OCC:

1.  The server serializes requests via the Lock.
2.  It processes Player A first. Version 42 -> 43. Broadcasts update.
3.  It processes Player B next. Player B sent base_version: 42.
4.  Server checks: 42 != 43. REJECTS Player B.
5.  Player B receives CONFLICT.
6.  Player B's client performs Rebase. It sees the word is now solved in the new matrix.
7.  Player B's client discards the move. Player B gets NO points.

This guarantees that the point is awarded strictly to the first request processed by the server lock.

## 7. Implementation Checklist for Developers

### Server (Python/FastAPI)

  - [ ] Add version (int) to the Game State class.
  - [ ] Wrap the state update logic in an asyncio.Lock() to ensure atomicity within the event loop.
  - [ ] Implement the if base_ver == curr_ver check.
  - [ ] Implement the CONFLICT response message type containing the latest state.

### Client (Android)

  - [ ] Store last_known_version in the repository/state manager.
  - [ ] Include last_known_version in every update_matrix network call.
  - [ ] Create a specific handler for CONFLICT network responses.
  - [ ] Implement Rebase Logic:
    New_Submission = (Server_State + Local_Diff)
  - [ ] If Rebase reveals the word is already solved, trigger "Late Arrival" feedback for the user.