# Solution 004: Seed Selection with Static Offline Word Statistics

## Status
Draft. This document captures initial theses and will be expanded incrementally.

## 1) Core idea
- This is a fourth seed-selection mode.
- Seed is generated as a **set of letters**, not as a long dictionary word.

## 2) Offline statistics file for this mode
- Along with main dictionaries, the app ships an additional file (working name: `004.txt`).
- `004.txt` is generated by a lab script that simulates seed-selection logic used by the app.
- The file contains per-word statistics for dictionary words.

## 3) How crossword words use `004.txt`
- Crosswords are built from allowed dictionary words with forbidden words excluded.
- When needed, crossword words are matched against stats from `004.txt`.
- If a word is missing in `004.txt`, its stat value is treated as `0`.

## 4) Ownership and update rules for all `004*` files
- `004.txt`, `004.letters.txt`, and `004.meta.json` are read-only for the Android app.
- The app never edits any `004*` file locally.
- `004*` files change only via content updates.
- `004*` files can be delivered with a new app version.
- `004*` files can also be delivered through the same dictionary update flow in `Settings -> Update Dictionary`.

## 5) Letter-exclusion step before seed selection
- One optional pre-step before choosing a seed letter set: exclude 1, 2, or 3 frequent letters for the current round.
- The number of excluded letters (1/2/3) may be random.
- Exclusion probability for each letter is based on global letter frequency across dictionaries.
- This frequency data comes from another offline file (working name: `004.letters.txt`).
- `004.letters.txt` is also produced by lab tooling.

## 6) Version metadata control
- `004` artifacts should include a metadata file (working name: `004.meta.json`).
- `004.meta.json` stores input fingerprints for `words.txt`, `forbidden_words.txt`, generator script, and generator parameters/version.
- `004.meta.json` stores output fingerprints for `004.txt` and `004.letters.txt`.
- No cryptographic signature is required for this project scope.

## 7) File formats
`004.txt` format:
- One entry per line: `<word>:<count>`.
- `word` uses the same normalization as `words.txt` (currently lowercase alphabetic token).
- `count` is non-negative integer.
- If duplicate words appear, the last line wins (generator should avoid duplicates).

`004.letters.txt` format:
- One entry per line: `<letter>:<count>`.
- `letter` uses the same normalization as dictionary letters (currently one lowercase character).
- `count` is non-negative integer.
- If duplicate letters appear, the last line wins (generator should avoid duplicates).

`004.meta.json` format:
- UTF-8 JSON object.
- Required top-level fields:
- `format` (string, example: `v1`);
- `generated_at_utc` (ISO-8601 UTC string);
- `generator` (object with script/version info);
- `inputs` (object with input file hashes);
- `outputs` (object with output file hashes).
- Hash algorithm: `sha256`.

Comments and ignored lines:
- A line that starts with `#` is a comment and must be ignored by parser.
- Empty lines must be ignored by parser.
- Inline comments are not supported to keep parsing simple.
- Comment rules above apply to `004.txt` and `004.letters.txt` only.
- `004.meta.json` must be valid JSON and does not support comments.

Examples:
```text
# format=v1
# source=lab
apple:123
note:97
```

```text
# format=v1
a:18452
e:21301
```

```json
{
  "format": "v1",
  "generated_at_utc": "2026-02-15T21:10:00Z",
  "generator": {
    "script": "lab/crossword_repeatability/generate_004.py",
    "version": "1.0.0"
  },
  "inputs": {
    "words_txt_sha256": "4c6c3c2a...f8b1",
    "forbidden_words_txt_sha256": "a91f0d5e...2d44",
    "generator_script_sha256": "f31b8f7a...8aa0",
    "generator_params_sha256": "6b2c93aa...93de"
  },
  "outputs": {
    "004_txt_sha256": "71de9f3a...112c",
    "004_letters_txt_sha256": "f2b5d314...9b70"
  }
}
```

## 8) Draft generation algorithm (unfinished)
This section captures the current draft flow and is intentionally incomplete.

Initial state:
- Keep runtime state in memory only (no disk persistence for this state):
- `previousSeed`;
- `previousFullWordSet` (all buildable words from previous accepted seed);
- `previousCrosswordWordSet` (words that actually entered previous crossword layout).
- All three can be empty after app restart.

Main loop (`attempt` from `1` to configured max attempts):
1. Randomly choose `excludeCount` in range `1..3`.
2. From letters of `previousSeed`, select letters to exclude using `004.letters.txt` frequency (prefer higher-frequency letters first).
3. Build full alphabet and remove excluded letters.
4. Generate a new seed letter set from the reduced alphabet, with length from current configuration.
5. Build `fullWordSet` for this seed:
- collect all words buildable from seed;
- keep only words with length `>= MIN_CROSSWORD_WORD_LENGTH`.
6. Run pre-layout overlap check against previous full set:
- `overlapRatio = |fullWordSet âˆ© previousFullWordSet| / |fullWordSet|`.
- reject seed if `overlapRatio >= 0.10` (10% or more).
7. Split words before layout build:
- `layoutInputWordSet = fullWordSet - previousCrosswordWordSet`.
8. Build crossword layout from `layoutInputWordSet` (not from the original full set):
- layout builder should try to place all words from `layoutInputWordSet`, or the maximum possible subset;
- structural limits (including `14 x 14`) should be enforced during placement, not only after generation.
9. Build one final `missingWords` set for this candidate:
- `missingWords = fullWordSet - layoutWordSet`;
- this includes both categories:
  - words removed before layout because they were in previous crossword;
  - words that were in layout input but still did not enter final layout.
10. Validate by layout result:
- reject seed if `layout.words.size < MIN_CROSSWORD_WORD_COUNT`.
11. Apply mode-specific extra validation:
- for letter-generated modes, require all seed letters to be used in layout words (`areAllSeedLettersUsed` behavior).
12. Apply structural layout validation constraints:
- placement rules from current crossword generator;
- max layout bounds `<= 14 x 14`;
- reject layout if constraints are violated.
13. If seed is rejected, add it to rejected list and log rejection reason.
14. If seed passed checks, store candidate as `(seed, fullWordSet, layoutWordSet, missingWords)`.
15. If no best candidate exists yet, mark current candidate as best.
16. If best candidate already exists, compare current vs best by weighted score rules from section `10`.
17. Continue loop until max attempts is reached, always comparing with current best candidate.

After loop:
1. Best candidate becomes the finalist `(seed, fullWordSet, layoutWordSet, missingWords)`.
2. Build crossword from finalist `layoutWordSet`.
3. Use finalist `missingWords` as the only missing/not-in-crossword list.
4. If no finalist was found:
- set generation error state;
- keep existing crossword/grid if one already exists;
- only clear state when there is no previous grid to keep.

State update rules:
- If player completes the crossword, save finalist state for next round:
- `previousSeed = finalist.seed`;
- `previousFullWordSet = finalist.fullWordSet`;
- `previousCrosswordWordSet = finalist.layoutWordSet`.
- If player presses reset/rebuild, restart flow from step 1 of main loop (new random `excludeCount`).

Auto-regeneration trigger:
- when dictionary/eligible seed pool changes and current seed becomes ineligible, trigger a new generation cycle automatically.

## 9) Explicit step matrix by mode
To keep logic explicit and easy to mirror in both Kotlin and Python, each mode uses the same fixed step slots.

Fixed step slots:
1. `step_build_full_word_set`
2. `step_reject_if_full_overlap_ge_10_percent`
3. `step_prepare_layout_input`
4. `step_build_layout_with_in_generation_limits`
5. `step_mode_extra_a`
6. `step_mode_extra_b`
7. `step_build_missing_words_and_validate_layout`

Mode-to-steps mapping:
- `m1 = [step_build_full_word_set, step_reject_if_full_overlap_ge_10_percent, step_prepare_layout_input, step_build_layout_with_in_generation_limits, none, none, step_build_missing_words_and_validate_layout]`
- `m2 = [step_build_full_word_set, step_reject_if_full_overlap_ge_10_percent, step_prepare_layout_input, step_build_layout_with_in_generation_limits, step_mode2_extra, none, step_build_missing_words_and_validate_layout]`
- `m3 = [step_build_full_word_set, step_reject_if_full_overlap_ge_10_percent, step_prepare_layout_input, step_build_layout_with_in_generation_limits, step_all_seed_letters_used, none, step_build_missing_words_and_validate_layout]`
- `m4 = [step_build_full_word_set, step_reject_if_full_overlap_ge_10_percent, step_prepare_layout_input, step_build_layout_with_in_generation_limits, step_all_seed_letters_used, step_use_004_stats, step_build_missing_words_and_validate_layout]`

Rules:
- `none`/`null` means the slot is intentionally skipped for that mode.
- Runner executes slots strictly in order from 1 to 7.
- Any failed step rejects the seed immediately with a reason.
- No hidden branching should decide whether a step is active; activation is defined only by the matrix above.

Implementation note:
- Python: `dict[mode] -> list[callable | None]`
- Kotlin: `Map<Mode, List<Step?>>`
- Keep slot names identical in both languages for easier logic sync.

## 10) Candidate comparison score (new vs current best)
Comparison is applied only after a candidate passes all hard reject filters.

The `004.txt` `count` values are word-level stats. Seed is compared indirectly through words produced by that seed:
- `fullWordSet` (all buildable words for seed);
- `layoutWordSet` (words that entered layout).

If a word is missing in `004.txt`, use `count = 0`.

Normalized components (`0..1`):
- `pL`: layout coverage quality, `pL = |layoutWordSet| / max(1, |layoutInputWordSet|)`.
- `pRfull`: average rarity of `fullWordSet`, where `rarity(word) = 1 / (1 + count004(word))`.
- `pMissing`: inverse missing ratio, `pMissing = 1 - (|missingWords| / max(1, |fullWordSet|))`.
- `pOverlap`: inverse pre-layout overlap ratio, `pOverlap = 1 - overlapRatio`.
- `pRlayout`: average rarity of `layoutWordSet`, using same rarity formula as above.
- `pSeedDiff`: seed difference from previous seed (normalized to `0..1`, higher is better).

Score formula:
- `S = 2*pL + 2*pRfull + 1*pMissing + 1*pOverlap + 1*pRlayout + 1*pSeedDiff`

Weights:
- `wL = 2`
- `wRfull = 2`
- all other weights are `1`

Selection rule:
- candidate with larger `S` wins;
- if equal score, tie-break in this order:
1. larger `|layoutWordSet|`
2. lower `overlapRatio`
3. deterministic seed order (stable lexical compare)

## 11) Developer diagnostics logging requirements
- The generator must log full decision flow for each new game attempt.
- Logs must include:
- mode, config, and run/session id;
- selected/excluded letters and seed candidates;
- `fullWordSet` size, pre-layout overlap ratio, and threshold comparison;
- counts for `layoutInputWordSet`, final layout words, and final `missingWords`;
- reject reasons per attempt;
- candidate comparison decisions and chosen finalist;
- score components (`pL`, `pRfull`, `pMissing`, `pOverlap`, `pRlayout`, `pSeedDiff`) and total `S`;
- counters (attempts, rejects by reason, successes).
- Logs must be accessible to developers for analysis:
- local persisted log files with rolling retention;
- export/share action from app settings or debug menu.

## 12) Open points to define next
- How stats from `004.txt` influence ranking of candidate seed letter sets.
- Exact randomization policy for excluding 1/2/3 letters.
- Fallback behavior when update files are missing, stale, or partially incompatible.

## 13) Optional ideas (not decided yet)
- Optional GitHub CI flow for `004*` regeneration checks:
1. Trigger when `words.txt`, `forbidden_words.txt`, or generator files change.
2. Run generator in CI and rebuild `004.txt`, `004.letters.txt`, and `004.meta.json`.
3. Compare generated outputs with repository files.
4. If mismatched, fail the job with a clear message to regenerate and commit `004*`.
5. Optional later step: add a bot PR mode that commits regenerated `004*` automatically.
