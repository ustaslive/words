# Решение 001: Ограниченный перебор + локальные счетчики

## Цель
Снизить массовые повторы слов между соседними играми при фиксированном и предсказуемом времени генерации.

## Хранимые данные
- `wordToIndex`: соответствие `слово -> индекс`.
- `countInLast10[index]`: число появлений слова в последних `10` играх.
- `prevGameSet`: множество слов предыдущей игры.
- `last10Games`: кольцевой буфер из `10` списков слов.
- `gameSeq`: последовательный номер игры (`1, 2, 3...`).

## Где хранятся данные
- Во время генерации данные находятся в памяти.
- После принятой игры сохраняется компактный снимок состояния во внутреннее хранилище приложения.
- При старте приложения состояние загружается из внутреннего хранилища и продолжает счет с прошлого запуска.
- Если снимок отсутствует или поврежден, состояние начинается с пустого.

## Рестарт и обновление приложения
- Обычный рестарт: состояние сохраняется и восстанавливается.
- Обновление приложения: состояние сохраняется, если словарь не изменился.
- Изменение словаря определяется по контрольной сумме содержимого `words.txt` и `forbidden_words.txt`.
- При изменении словаря состояние сбрасывается и накапливается заново на новом словаре.

## Совместимость с текущими словарями
- Формат `words.txt` остается прежним.
- Формат `forbidden_words.txt` остается прежним.
- Дополнительные поля в этих файлах не требуются.

## Обновление данных после принятой игры
1. Получить список слов нового кроссворда.
2. Если буфер `last10Games` заполнен, удалить самую старую игру и уменьшить `countInLast10` для ее слов.
3. Добавить новую игру в буфер и увеличить `countInLast10` для ее слов.
4. Пересобрать `prevGameSet` из слов новой игры.
5. Увеличить `gameSeq` на `1`.

## Правила выбора нового кроссворда
1. Сгенерировать не более `30` кандидатов.
2. Отбросить кандидаты, не проходящие базовые ограничения качества.
3. Для каждого оставшегося кандидата посчитать:
- `K`: количество слов кандидата.
- `overlapPrevCount`: число слов, которые есть в `prevGameSet`.
- `newIn10Count`: число слов с `countInLast10 == 0`.
- `overusedCount`: число слов с `countInLast10 >= 3`.
4. Отбросить кандидаты, где `overlapPrevCount / K > 0.40`.
5. Выбрать лучший кандидат по приоритетам:
- максимальный `newIn10Count`,
- минимальный `overusedCount`,
- минимальный `overlapPrevCount`.
6. Из топ-`3` кандидатов выбрать случайно один.
7. Если после фильтра кандидатов нет, повторить выбор с порогом `0.50`.

## Оценка нагрузки
- Обновление после игры: `O(K)`, где `K` обычно в диапазоне `9..20`.
- Оценка одного кандидата: `O(K)`.
- Полная оценка на игру: не более `30 * K` проверок слов.
- Проходов по всему словарю (`7000+` слов) на каждом ходу нет.

## Метрики для проверки эффекта
- Доля пересечения с предыдущей игрой:
- `overlap_i = |Gi ∩ Gi-1| / |Gi|`.
- Среднее пересечение по серии:
- `avgOverlap = (overlap_2 + ... + overlap_n) / (n - 1)`.
- Доля игр с пересечением выше `50%`.
- Среднее `newIn10Count` по серии игр.

## Ожидаемый результат
- Повторы остаются, но перестают доминировать.
- Выбор кроссворда остается быстрым и ограниченным по времени.
- Подход одинаково применяется к любому режиму генерации seed.
