# Решение 003: Предварительная оценка seed с сохранением результата

## 1) Суть решения
Перед полной сборкой кроссворда сначала быстро оцениваются много seed-кандидатов.  
Результат такой оценки сохраняется. Если тот же seed встречается снова, пересчет не нужен.

Идея:
- меньше тяжелых расчетов;
- больше внимания seed, которые дают редкие слова.

## 2) Что такое seed в этом документе
Seed = набор букв, из которого потом строится кроссворд.

Для хранения используется `seedSignature`:
- буквы seed, отсортированные в стабильном порядке;
- одинаковые по составу буквы дают одинаковую сигнатуру.

## 3) Какие данные сохраняются
- `seedStatsBySignature`: словарь `seedSignature -> статистика`.
- `seenEver[word]`: сколько раз слово показывалось за все время.
- `lastSeenGame[word]`: в какой игре слово показывалось последний раз.
- `rareWordSet`: множество редких слов.
- `dictHash`: контрольная сумма текущих `words.txt` и `forbidden_words.txt`.

Статистика для одного `seedSignature`:
- `buildableCount`: сколько слов словаря можно собрать из букв этого seed.
- `rareBuildableCount`: сколько из них входят в `rareWordSet`.
- `dictHashAtCalc`: на каком `dictHash` это считалось.

## 4) Где живут данные
- Во время работы: в памяти.
- Между запусками: снимок во внутреннем хранилище приложения.
- При старте: состояние загружается из снимка.

## 5) Что считается редким словом
Слово попадает в `rareWordSet`, если выполняется хотя бы одно:
- `seenEver[word] <= 1` после минимум `200` сыгранных игр;
- слово не встречалось последние `200` игр.

Пересчет `rareWordSet` выполняется раз в `20` игр.

## 6) Как проходит один ход генерации
Параметры:
- до `60` seed-кандидатов на ход;
- не более `10` новых полных расчетов seed за ход;
- полная сборка кроссворда только для лучших `5` seed.

Шаги:
1. Получить до `60` seed-кандидатов из текущего режима.
2. Для каждого кандидата получить `seedSignature`.
3. Если для сигнатуры уже есть статистика и `dictHashAtCalc == dictHash`, использовать ее сразу.
4. Если статистики нет, выполнить полный расчет по словарю:
- посчитать `buildableCount`;
- посчитать `rareBuildableCount`;
- сохранить результат в `seedStatsBySignature`.
5. Полный расчет для нового seed делается не более `10` раз за ход.
6. Для всех seed со статистикой посчитать предварительный балл:
- `preScore = 2 * rareBuildableCount + 1 * buildableCount`.
7. Выбрать топ-`5` seed по `preScore`.
8. Только для этих `5` seed выполнить полную сборку кроссворда текущим алгоритмом.
9. Применить стандартный фильтр повторов с предыдущей игрой и выбрать итоговый кроссворд.

Пояснение:
- фраза "дорогой промах кэша" в старой версии означала именно шаг 4: seed новый, сохраненной статистики для него нет, нужно считать с нуля.

## 7) Что происходит после принятой игры
1. Для каждого слова нового кроссворда: `seenEver[word] += 1`.
2. Для каждого слова нового кроссворда: `lastSeenGame[word] = gameSeq`.
3. Каждые `20` игр пересчитать `rareWordSet`.
4. Увеличить `gameSeq`.

## 8) Что происходит при изменении словаря
Формат `words.txt` и `forbidden_words.txt` не меняется.

При изменении `dictHash`:
1. `seedStatsBySignature` очищается полностью, потому что статистика seed стала неактуальной.
2. `seenEver` и `lastSeenGame` очищаются от слов, которых больше нет в разрешенном словаре.
3. Новые слова стартуют с `0`.
4. `rareWordSet` пересчитывается заново.

## 9) Нагрузка
- На одном ходе тяжелый расчет для новых seed ограничен числом `10`.
- Для seed, которые уже встречались, используется готовая статистика без полного пересчета.
- Полная сборка кроссворда делается максимум для `5` seed за ход.

## 10) Что решение дает
- Сокращает число тяжелых перерасчетов.
- Дает приоритет seed, которые потенциально содержат больше редких слов.
- Повышает шанс увидеть недопредставленные слова без полного перебора всех вариантов каждый ход.
