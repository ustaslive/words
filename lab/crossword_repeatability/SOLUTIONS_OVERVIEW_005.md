# Решение 005: Итеративная замена букв с контролем повторов

## 1) Цель
Уменьшить долю повторяющихся слов относительно предыдущей игры (а для первой игры - относительно самых частых слов словаря), при ограниченном времени генерации.

## 2) Входные данные
1. Разрешенный словарь: `words.txt` после фильтрации `forbidden_words.txt`.
2. Слова предыдущей игры: `previousRoundWordSet`.
3. Внешний файл статистики: `005.stat.txt`.

Требования к `005.stat.txt`:
1. Файл поставляется снаружи.
2. В комментарии в начале файла хранится число кроссвордов, по которым собрана статистика.
3. Формат строк: `<слово>:<число появлений>`.
4. В файле находятся только слова, которые встречались хотя бы `1` раз.
5. Для слова из `words.txt`, которого нет в `005.stat.txt`, частота считается равной `0`.

Пример:
```text
# crosswords_generated=100000
NOTE:1245
TONE:1188
RARE:21
```

## 3) Параметры и константы (все используемые)
1. `MIN_CROSSWORD_WORD_LENGTH = 4`
минимальная длина слова, которое участвует в `buildableWordSet`.

2. `MIN_CROSSWORD_WORD_COUNT = 9`
минимальное количество слов в итоговом кроссворде.

3. `MAX_CROSSWORD_GENERATION_ATTEMPTS = 100`
максимальное количество полных перезапусков генерации с новым случайным `seedLetters`.

4. `MAX_LETTER_SWAP_CYCLES = 5`
максимальное количество локальных циклов "удалить букву + добавить букву" внутри одного `seedLetters`.

5. `TOP_FREQUENT_WORD_SHARE = 0.10`
верхняя доля самых частых слов от полного словаря: 10%.

6. `MAX_REPEAT_SHARE_WITH_CONTROL_SET`
максимально допустимая доля повторов по контрольному набору слов.
Задается параметром (пример рабочего значения: `0.40`).

7. `ALPHABET = A..Z`
алфавит для генерации и подстановки букв.

8. `seedMinLength`, `seedMaxLength`
минимальная и максимальная длина случайного `seedLetters` для текущего режима.

9. `seedLetters`
текущий список случайных букв.
Буквы могут повторяться.

10. `SEED_VOWEL_DISTRIBUTION`
распределение числа гласных в новом `seedLetters`:
- `2` гласных: `3` из `10`;
- `3` гласных: `5` из `10`;
- `4` гласных: `2` из `10`.
Количество гласных выбирается случайно по этим весам.

## 4) Что считается один раз перед серией генерации
1. Загрузить словарь.
2. Загрузить `005.stat.txt`.
3. Построить `wordFrequencyMap` для всех слов словаря:
1. если слово есть в `005.stat.txt`, взять его частоту;
2. если слова нет в `005.stat.txt`, поставить `0`.
4. Отсортировать слова по убыванию частоты.
5. При равной частоте сортировать по алфавиту.
6. Взять верхние `ceil(dictionarySize * TOP_FREQUENT_WORD_SHARE)` слов.
7. Сохранить их в `topFrequentWordSet`.

Важно:
`topFrequentWordSet` строится один раз на текущую версию словаря и `005.stat.txt`.

## 5) Что пересчитывается на каждом цикле замены
1. `buildableWordSet(seedLetters)`:
слова словаря, которые:
- собираются из букв `seedLetters`;
- имеют длину не меньше `MIN_CROSSWORD_WORD_LENGTH`.

2. `repeatControlSet`:
1. если `previousRoundWordSet` не пуст, использовать `previousRoundWordSet`;
2. если `previousRoundWordSet` пуст, использовать `topFrequentWordSet`.

3. `repeatSourceWordSet`:
пересечение `buildableWordSet(seedLetters)` и `repeatControlSet`.

4. `repeatShare`:
`repeatSourceWordSet.size / max(1, buildableWordSet(seedLetters).size)`.

Почему это пересчитывается каждый цикл:
после каждой замены `seedLetters` меняется, значит меняется `buildableWordSet`, а значит и `repeatSourceWordSet`, и `repeatShare`.

## 6) Алгоритм
1. Выполнять не более `MAX_CROSSWORD_GENERATION_ATTEMPTS` полных попыток.

2. На каждой полной попытке:
1. Сгенерировать новый случайный `seedLetters` длиной `seedMinLength..seedMaxLength`.
2. При генерации `seedLetters` сначала случайно выбрать число гласных по распределению:
- `2` гласных с весом `3`;
- `3` гласных с весом `5`;
- `4` гласных с весом `2`.
3. Затем добрать остальные позиции согласными и перемешать буквы.
4. Создать `remainingAdditionAlphabet`:
буквы `ALPHABET`, которых нет в текущем `seedLetters`.
5. Создать `blockedReturnLetters = пусто`.

3. Внутри полной попытки выполнить до `MAX_LETTER_SWAP_CYCLES` циклов:
1. Построить `buildableWordSet(seedLetters)`.
2. Если `buildableWordSet(seedLetters).size < MIN_CROSSWORD_WORD_COUNT`:
1. сразу завершить текущую полную попытку;
2. начать новую полную попытку с новым случайным `seedLetters`;
3. на этом шаге не выполнять удаление/добавление букв.
3. Построить `repeatSourceWordSet`.
4. Посчитать `repeatShare`.
5. Если `repeatShare <= MAX_REPEAT_SHARE_WITH_CONTROL_SET`:
1. попытаться построить кроссворд стандартным построителем;
2. проверить ограничения построителя;
3. проверить `layoutWordCount >= MIN_CROSSWORD_WORD_COUNT`;
4. если все проверки пройдены, принять результат и завершить генерацию.
5. если доля повторов уже допустима, но кроссворд все равно невалиден:
1. завершить текущую полную попытку;
2. начать новую полную попытку с новым случайным `seedLetters`;
3. в этой ситуации не выполнять удаление/добавление букв.
6. Если `repeatShare > MAX_REPEAT_SHARE_WITH_CONTROL_SET`, выполнить замену буквы:
1. посчитать частоты согласных по словам из `repeatSourceWordSet`;
2. учитывать повторы букв в слове;
3. в кандидаты на удаление брать только те согласные, которые встречаются в `seedLetters` ровно `1` раз;
4. выбрать согласную с максимальным счетчиком;
5. при равенстве выбрать случайно;
6. если кандидат найден, удалить эту букву из `seedLetters`;
7. если кандидат не найден, удалить:
- случайную согласную, встречающуюся в `seedLetters` ровно `1` раз;
- иначе случайную букву, встречающуюся в `seedLetters` ровно `1` раз;
- иначе любую случайную букву.
8. добавлять удаленную букву в `blockedReturnLetters`;
9. построить `addPool = remainingAdditionAlphabet - blockedReturnLetters`;
10. если `addPool` пуст, завершить текущую полную попытку как неуспешную;
11. выбрать случайную букву из `addPool` и добавить в `seedLetters`;
12. удалить добавленную букву из `remainingAdditionAlphabet`.

4. Если после `MAX_LETTER_SWAP_CYCLES` не получен валидный результат с допустимой долей повторов, полная попытка считается неуспешной и запускается новый случайный `seedLetters`.

5. Если исчерпан `MAX_CROSSWORD_GENERATION_ATTEMPTS`, вернуть ошибку генерации.

## 7) Правила, которые зафиксированы явно
1. `repeatSourceWordSet` нельзя считать один раз на всю полную попытку, потому что он меняется после каждой замены `seedLetters`.
2. На каждой итерации обязательно порядок:
изменили `seedLetters` -> пересобрали `buildableWordSet` -> пересчитали повторы -> приняли решение о следующей замене или сборке кроссворда.
3. Если на текущем `seedLetters` слов меньше `MIN_CROSSWORD_WORD_COUNT`, мутация не делается: сразу новая полная попытка.
4. Если доля повторов уже в норме, но layout невалиден, мутация не делается: сразу новая полная попытка.
5. Мутация разрешена только когда:
- слов достаточно для кроссворда (`buildableWordSet.size >= MIN_CROSSWORD_WORD_COUNT`);
- и доля повторов выше порога (`repeatShare > MAX_REPEAT_SHARE_WITH_CONTROL_SET`).
6. Новая буква добавляется не из полного `ALPHABET`, а только из `remainingAdditionAlphabet`.
7. Буквы, удаленные как доминирующие в рамках текущего `seedLetters`, не возвращаются в этом же `seedLetters` (через `blockedReturnLetters`).
