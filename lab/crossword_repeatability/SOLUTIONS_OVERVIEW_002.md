# Решение 002: Квоты по недавней истории

## 1) Суть решения
Выбор нового кроссворда делается не только по принципу "не повторить прошлую игру", но и по квотам:
- в игре должно быть достаточно слов, которых не было в недавнем окне;
- в игре не должно быть слишком много слов, которые и так часто повторялись недавно.

## 2) Главный параметр: `countInWindow`
`countInWindow[word]` = сколько раз слово встретилось в последних `40` принятых играх.

Пример:
- если слово в последних 40 играх не встречалось ни разу, `countInWindow = 0`;
- если встретилось 2 раза, `countInWindow = 2`;
- если встретилось 5 раз, `countInWindow = 5`.

По этому числу слово получает класс:
- `fresh`: `countInWindow == 0`;
- `warm`: `countInWindow == 1` или `2`;
- `hot`: `countInWindow >= 3`.

## 3) Где живут данные
В памяти во время работы:
- `windowGames`: очередь из последних `40` игр (каждая игра = список слов кроссворда);
- `countInWindow`: словарь `слово -> число` для окна из `40` игр;
- `seenEver`: словарь `слово -> сколько раз встречалось за все время`;
- `prevGameSet`: множество слов предыдущей игры.

На диске (внутреннее хранилище приложения) хранится снимок:
- `windowGames`;
- `seenEver`;
- служебный номер игры.

`countInWindow` после запуска можно либо загрузить, либо заново пересчитать из `windowGames`.

## 4) Как обновляется `countInWindow`
После принятия новой игры:
1. Если в `windowGames` уже `40` игр, удаляется самая старая.
2. Для каждого слова удаленной игры делается `countInWindow[word] -= 1`.
3. Новая игра добавляется в `windowGames`.
4. Для каждого слова новой игры делается `countInWindow[word] += 1`.
5. Для каждого слова новой игры делается `seenEver[word] += 1`.
6. `prevGameSet` заменяется словами новой игры.

Важно:
- обновляются только слова из удаленной и новой игры;
- прохода по всему словарю на каждом ходу нет.

## 5) Как выбирается кроссворд на одном ходу
Параметры:
- максимум `30` кандидатов;
- фильтр пересечения с прошлой игрой: `overlapPrev <= 0.40`.

Шаги:
1. Генератор получает до `30` валидных кандидатов.
2. Для каждого кандидата (с `K` словами) считаются:
- `overlapPrevCount`: сколько слов есть в `prevGameSet`;
- `freshCount`: сколько слов имеют `countInWindow == 0`;
- `hotCount`: сколько слов имеют `countInWindow >= 3`;
- `freshShare = freshCount / K`;
- `hotShare = hotCount / K`.
3. Кандидат отбрасывается, если `overlapPrevCount / K > 0.40`.
4. Для оставшихся считается штраф:
- `penaltyFresh = max(0, 0.30 - freshShare)`;
- `penaltyHot = max(0, hotShare - 0.25)`;
- `penalty = 3 * penaltyFresh + 2 * penaltyHot + 1 * (overlapPrevCount / K)`.
5. Выбирается кандидат с минимальным `penalty`.
6. При равенстве выбирается кандидат с меньшей суммой `seenEver` по словам.
7. Если снова равенство, выбирается случайно из топ-`3`.

## 6) Что происходит при изменении словаря
Формат `words.txt` и `forbidden_words.txt` не меняется.

После изменения словаря:
1. Строится новый разрешенный набор слов.
2. Из `windowGames` удаляются слова, которых больше нет в разрешенном наборе.
3. В `seenEver` удаляются такие же слова.
4. `countInWindow` пересчитывается из очищенного `windowGames`.
5. Новые слова стартуют с `0`.

То есть статистика не сбрасывается полностью: сохраняется все, что относится к словам, которые остались в словаре.

## 7) Нагрузка
- оценка одного кандидата: `O(K)`;
- оценка хода: до `30 * K` проверок слов;
- обновление после игры: `O(K)`.

При типичных `K` (около `9..20`) это легкие операции.

## 8) Что решение дает
- меньше массовых повторов;
- регулярное давление в сторону слов, не встречавшихся в недавнем окне;
- предсказуемая нагрузка без перебора всего словаря на каждом ходе.
